<!DOCTYPE html>
<html lang="no">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Tower Defense ‚Äì Person vs Monstre</title>

<style>
  body {
    margin: 0;
    background: #1e1e1e;
    color: white;
    font-family: Arial, sans-serif;
    display: flex;
    flex-direction: column;
    align-items: center;
  }

  #ui {
    width: 100%;
    max-width: 1000px;
    display: flex;
    justify-content: space-between;
    padding: 10px;
    background: #111;
    box-sizing: border-box;
  }

  #leftPanel {
    display: flex;
    flex-direction: column;
    gap: 6px;
  }

  #stats, #waveInfo, #bestScore {
    font-size: 14px;
  }

  #towerShop {
    margin-top: 8px;
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
  }

  .towerBtn {
    background: #333;
    color: white;
    border: 1px solid #555;
    padding: 6px 8px;
    cursor: pointer;
    font-size: 12px;
  }

  .towerBtn:hover {
    background: #555;
  }

  button {
    background: #444;
    color: white;
    border: none;
    padding: 8px 12px;
    margin: 4px 0;
    cursor: pointer;
  }

  button:hover { background: #666; }

  canvas {
    background: #222;
    border: 2px solid white;
    touch-action: none;
  }

  #overlay {
    position: fixed;
    inset: 0;
    background: rgba(0,0,0,0.7);
    display: none;
    justify-content: center;
    align-items: center;
    flex-direction: column;
    color: white;
    z-index: 10;
  }

  #towerUI {
    margin-top: 8px;
    font-size: 13px;
  }

  .label {
    font-weight: bold;
  }
</style>
</head>

<body>

<div id="ui">
  <div id="leftPanel">
    <div id="stats"></div>
    <div id="waveInfo"></div>
    <div id="bestScore"></div>
    <button onclick="togglePause()">Pause</button>
    <div id="towerUI"></div>
  </div>

  <div>
    <div class="label">T√•rnbutikk</div>
    <div id="towerShop"></div>
    <button onclick="startGame()">Start / Restart</button>
  </div>
</div>

<canvas id="game" width="1000" height="500"></canvas>

<div id="overlay">
  <h1>Game Over</h1>
  <p id="finalScore"></p>
  <button onclick="startGame()">Spill igjen</button>
</div>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

let money, lives, score, wave, paused, gameRunning;
let enemies = [], towers = [], bullets = [], particles = [];
let selectedTower = null;
let spawnTimer = 0;
let enemiesToSpawn = 0;
let spawnInterval = 40;
let waveInProgress = false;

const bestScoreKey = "td_best_score";

const path = [
  {x: 0,   y: 250},
  {x: 250, y: 250},
  {x: 250, y: 120},
  {x: 550, y: 120},
  {x: 550, y: 380},
  {x: 900, y: 380},
  {x: 1000,y: 380}
];

// T√•rn-typer: Soldat (D) og Magiker (E)
const towerTypes = {
  soldier: {
    name: "Soldat",
    cost: 70,
    color: "steelblue",
    range: 150,
    damage: 22,
    fireRate: 26,
    projectileColor: "yellow",
    projectileSize: 4
  },
  mage: {
    name: "Magiker",
    cost: 90,
    color: "mediumorchid",
    range: 170,
    damage: 18,
    fireRate: 32,
    projectileColor: "cyan",
    projectileSize: 5,
    magic: true
  },
  splash: {
    name: "Bombekaster",
    cost: 120,
    color: "orange",
    range: 150,
    damage: 26,
    fireRate: 40,
    projectileColor: "orange",
    projectileSize: 5,
    splashRadius: 55
  },
  frost: {
    name: "Frost-t√•rn",
    cost: 100,
    color: "deepskyblue",
    range: 160,
    damage: 12,
    fireRate: 34,
    projectileColor: "lightcyan",
    projectileSize: 4,
    slowFactor: 0.5,
    slowDuration: 70
  }
};

let selectedTowerType = "soldier";

// Monster-typer
const enemyTypes = {
  ork:   { color: "green",      baseHp: 120, speed: 1.2, reward: 14 },
  zombie:{ color: "palegreen",  baseHp: 90,  speed: 0.8, reward: 10 },
  demon: { color: "crimson",    baseHp: 160, speed: 1.4, reward: 18 },
  slime: { color: "lime",       baseHp: 70,  speed: 1.8, reward: 9  },
  beast: { color: "saddlebrown",baseHp: 200, speed: 1.1, reward: 22 }
};

class Enemy {
  constructor(kind, wave) {
    this.kind = kind;
    const base = enemyTypes[kind];
    const scale = 1 + wave * 0.15;

    this.maxHp = base.baseHp * scale;
    this.hp = this.maxHp;
    this.speed = base.speed;
    this.baseSpeed = this.speed;
    this.color = base.color;
    this.reward = base.reward + Math.floor(wave * 0.5);

    this.pathIndex = 0;
    this.x = path[0].x;
    this.y = path[0].y;
    this.slowTimer = 0;
  }

  applySlow(factor, duration) {
    if (this.slowTimer <= 0) {
      this.speed = this.baseSpeed * factor;
    }
    this.slowTimer = Math.max(this.slowTimer, duration);
  }

  update() {
    if (this.slowTimer > 0) {
      this.slowTimer--;
      if (this.slowTimer <= 0) {
        this.speed = this.baseSpeed;
      }
    }

    const target = path[this.pathIndex + 1];
    if (!target) {
      lives--;
      this.hp = 0;
      return;
    }
    const dx = target.x - this.x;
    const dy = target.y - this.y;
    const d = Math.hypot(dx, dy);
    if (d < this.speed) {
      this.pathIndex++;
    } else {
      this.x += dx / d * this.speed;
      this.y += dy / d * this.speed;
    }
  }

  draw() {
    const size = 18;

    // Skygge
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(this.x, this.y + 7, size * 0.8, size * 0.35, 0, 0, Math.PI * 2);
    ctx.fill();

    // Kropp (monster)
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(this.x, this.y, size / 2, 0, Math.PI * 2);
    ctx.fill();

    // √òyne
    ctx.fillStyle = "black";
    ctx.beginPath();
    ctx.arc(this.x - 4, this.y - 3, 2, 0, Math.PI * 2);
    ctx.arc(this.x + 4, this.y - 3, 2, 0, Math.PI * 2);
    ctx.fill();

    // Munn
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.arc(this.x, this.y + 3, 5, 0, Math.PI);
    ctx.stroke();

    // HP-bar
    const barWidth = 30;
    const barHeight = 5;
    const hpRatio = Math.max(this.hp / this.maxHp, 0);
    ctx.fillStyle = "black";
    ctx.fillRect(this.x - barWidth/2, this.y - size - 8, barWidth, barHeight);
    ctx.fillStyle = hpRatio > 0.5 ? "lime" : hpRatio > 0.25 ? "yellow" : "red";
    ctx.fillRect(this.x - barWidth/2, this.y - size - 8, barWidth * hpRatio, barHeight);

    // Slow-gl√∏d
    if (this.slowTimer > 0) {
      ctx.strokeStyle = "cyan";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, size/2 + 4, 0, Math.PI * 2);
      ctx.stroke();
    }
  }
}

class Tower {
  constructor(x, y, typeKey) {
    const t = towerTypes[typeKey];
    this.typeKey = typeKey;
    this.x = x;
    this.y = y;
    this.range = t.range;
    this.damage = t.damage;
    this.fireRate = t.fireRate;
    this.cooldown = 0;
    this.level = 1;
    this.color = t.color;
    this.angle = 0;
  }

  getUpgradeCost() {
    return 50 + this.level * 35;
  }

  upgrade() {
    const cost = this.getUpgradeCost();
    if (money >= cost) {
      money -= cost;
      this.level++;
      this.damage = Math.round(this.damage * 1.35);
      this.range += 12;
      this.fireRate = Math.max(12, this.fireRate - 3);

      // Oppgraderings-partikler
      for (let i = 0; i < 12; i++) {
        particles.push(new Particle(this.x, this.y, this.color, 18, 0.9));
      }
    }
  }

  update() {
    if (this.cooldown > 0) {
      this.cooldown--;
    }

    let target = null;
    let bestProgress = -1;

    for (let e of enemies) {
      const dist = Math.hypot(e.x - this.x, e.y - this.y);
      if (dist < this.range) {
        const progress = e.pathIndex + dist / 1000;
        if (progress > bestProgress) {
          bestProgress = progress;
          target = e;
        }
      }
    }

    if (target) {
      this.angle = Math.atan2(target.y - this.y, target.x - this.x);
      if (this.cooldown <= 0) {
        bullets.push(new Bullet(this, target));
        this.cooldown = this.fireRate;

        // Skudd-partikler
        for (let i = 0; i < 4; i++) {
          particles.push(new Particle(
            this.x + Math.cos(this.angle) * 10,
            this.y + Math.sin(this.angle) * 10,
            towerTypes[this.typeKey].projectileColor,
            10,
            0.8
          ));
        }
      }
    }
  }

  draw() {
    // Skygge
    ctx.fillStyle = "rgba(0,0,0,0.35)";
    ctx.beginPath();
    ctx.ellipse(this.x, this.y + 7, 15, 6, 0, 0, Math.PI * 2);
    ctx.fill();

    // Glow hvis valgt
    if (selectedTower === this) {
      ctx.strokeStyle = "rgba(255,255,255,0.4)";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.arc(this.x, this.y, this.range, 0, Math.PI * 2);
      ctx.stroke();
    }

    // Kropp (person)
    ctx.save();
    ctx.translate(this.x, this.y);

    // Base
    ctx.fillStyle = this.color;
    ctx.beginPath();
    ctx.arc(0, 0, 14, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 2;
    ctx.stroke();

    // Kropp (person)
    ctx.fillStyle = "beige";
    // Hode
    ctx.beginPath();
    ctx.arc(0, -10, 6, 0, Math.PI * 2);
    ctx.fill();
    ctx.strokeStyle = "black";
    ctx.lineWidth = 1;
    ctx.stroke();

    // Kropp
    ctx.strokeStyle = "black";
    ctx.beginPath();
    ctx.moveTo(0, -4);
    ctx.lineTo(0, 6);
    ctx.stroke();

    // Armer
    ctx.beginPath();
    ctx.moveTo(0, -2);
    ctx.lineTo(-6, 4);
    ctx.moveTo(0, -2);
    ctx.lineTo(6, 4);
    ctx.stroke();

    // Ben
    ctx.beginPath();
    ctx.moveTo(0, 6);
    ctx.lineTo(-5, 14);
    ctx.moveTo(0, 6);
    ctx.lineTo(5, 14);
    ctx.stroke();

    // Kanon / stav
    ctx.rotate(this.angle);
    ctx.strokeStyle = this.typeKey === "mage" ? "cyan" : "white";
    ctx.lineWidth = 3;
    ctx.beginPath();
    ctx.moveTo(0, 0);
    ctx.lineTo(18, 0);
    ctx.stroke();

    ctx.restore();

    // Level
    ctx.fillStyle = "white";
    ctx.font = "10px Arial";
    ctx.textAlign = "center";
    ctx.textBaseline = "middle";
    ctx.fillText(this.level, this.x, this.y + 18);
  }
}

class Bullet {
  constructor(tower, enemy) {
    this.tower = tower;
    this.x = tower.x;
    this.y = tower.y;
    this.e = enemy;
    this.speed = 6;
    this.d = tower.damage;
    this.dead = false;
  }

  update() {
    if (!this.e || this.e.hp <= 0) {
      this.dead = true;
      return;
    }
    const dx = this.e.x - this.x;
    const dy = this.e.y - this.y;
    const d = Math.hypot(dx, dy);
    if (d < 6) {
      this.hit();
      this.dead = true;
    } else {
      this.x += dx / d * this.speed;
      this.y += dy / d * this.speed;
    }
  }

  hit() {
    const typeKey = this.tower.typeKey;
    const tType = towerTypes[typeKey];

    // Treff-partikler
    for (let i = 0; i < 8; i++) {
      particles.push(new Particle(this.e.x, this.e.y, tType.projectileColor, 14, 0.85));
    }

    if (typeKey === "splash") {
      for (let e of enemies) {
        const dist = Math.hypot(e.x - this.e.x, e.y - this.e.y);
        if (dist <= (tType.splashRadius + this.tower.level * 4)) {
          e.hp -= this.d;
          if (e.hp <= 0) {
            this.killEnemy(e);
          }
        }
      }
    } else {
      this.e.hp -= this.d;
      if (typeKey === "frost") {
        this.e.applySlow(tType.slowFactor, tType.slowDuration + this.tower.level * 10);
      }
      if (this.e.hp <= 0) {
        this.killEnemy(this.e);
      }
    }
  }

  killEnemy(e) {
    money += e.reward;
    score += e.reward;

    // D√∏d-partikler
    for (let i = 0; i < 18; i++) {
      particles.push(new Particle(e.x, e.y, e.color, 20, 0.9));
    }
  }

  draw() {
    const tType = towerTypes[this.tower.typeKey];
    ctx.fillStyle = tType.projectileColor;
    ctx.beginPath();
    ctx.arc(this.x, this.y, tType.projectileSize, 0, Math.PI * 2);
    ctx.fill();
  }
}

class Particle {
  constructor(x, y, color, maxDist, life) {
    this.x = x;
    this.y = y;
    this.color = color;
    this.life = life;
    this.maxLife = life;
    const angle = Math.random() * Math.PI * 2;
    const speed = Math.random() * 2 + 0.5;
    this.vx = Math.cos(angle) * speed;
    this.vy = Math.sin(angle) * speed;
  }

  update() {
    this.x += this.vx;
    this.y += this.vy;
    this.life -= 0.03;
  }

  draw() {
    if (this.life <= 0) return;
    const alpha = this.life / this.maxLife;
    ctx.fillStyle = `rgba(${hexToRgb(this.color)},${alpha})`;
    ctx.beginPath();
    ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
    ctx.fill();
  }

  isDead() {
    return this.life <= 0;
  }
}

function hexToRgb(color) {
  const ctxTmp = document.createElement("canvas").getContext("2d");
  ctxTmp.fillStyle = color;
  const computed = ctxTmp.fillStyle; // blir til rgb(...)
  const m = computed.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (!m) return "255,255,255";
  return `${m[1]},${m[2]},${m[3]}`;
}

function setupTowerShop() {
  const shop = document.getElementById("towerShop");
  shop.innerHTML = "";
  Object.entries(towerTypes).forEach(([key, t]) => {
    const btn = document.createElement("button");
    btn.className = "towerBtn";
    btn.textContent = `${t.name} (${t.cost})`;
    btn.onclick = () => {
      selectedTowerType = key;
      selectedTower = null;
      updateTowerUI();
    };
    shop.appendChild(btn);
  });
}

function startGame() {
  money = 160;
  lives = 15;
  score = 0;
  wave = 1;
  enemies = [];
  towers = [];
  bullets = [];
  particles = [];
  paused = false;
  gameRunning = true;
  spawnTimer = 0;
  enemiesToSpawn = 0;
  spawnInterval = 40;
  waveInProgress = false;
  selectedTower = null;
  document.getElementById("overlay").style.display = "none";
  setupTowerShop();
  updateTowerUI();
  loop();
}

function startWave() {
  waveInProgress = true;
  const baseCount = 7 + Math.floor(wave * 1.4);
  enemiesToSpawn = baseCount;
  spawnInterval = Math.max(16, 40 - wave * 1.3);
}

function spawnEnemy() {
  if (enemiesToSpawn <= 0) return;

  spawnTimer++;
  if (spawnTimer < spawnInterval) return;
  spawnTimer = 0;

  const kinds = Object.keys(enemyTypes);
  const idx = Math.floor(Math.random() * kinds.length);
  const kind = kinds[idx];

  enemies.push(new Enemy(kind, wave));
  enemiesToSpawn--;
}

function togglePause() {
  paused = !paused;
}

function loop() {
  if (!gameRunning) return;

  if (!paused) {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawPath();

    if (!waveInProgress && enemies.length === 0) {
      startWave();
    }

    if (waveInProgress) {
      spawnEnemy();
      if (enemiesToSpawn <= 0 && enemies.length === 0) {
        waveInProgress = false;
        wave++;
        money += 50 + wave * 6;
      }
    }

    enemies.forEach(e => e.update());
    towers.forEach(t => t.update());
    bullets.forEach(b => b.update());
    particles.forEach(p => p.update());

    enemies = enemies.filter(e => e.hp > 0);
    bullets = bullets.filter(b => !b.dead);
    particles = particles.filter(p => !p.isDead());

    enemies.forEach(e => e.draw());
    towers.forEach(t => t.draw());
    bullets.forEach(b => b.draw());
    particles.forEach(p => p.draw());

    drawHUD();

    if (lives <= 0) {
      endGame();
    }
  }

  requestAnimationFrame(loop);
}

function drawPath() {
  ctx.strokeStyle = "#444";
  ctx.lineWidth = 40;
  ctx.lineCap = "round";
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();

  ctx.strokeStyle = "#666";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(path[0].x, path[0].y);
  for (let i = 1; i < path.length; i++) {
    ctx.lineTo(path[i].x, path[i].y);
  }
  ctx.stroke();
}

function drawHUD() {
  document.getElementById("stats").innerText =
    `üí∞ ${money}   ‚ù§Ô∏è ${lives}   ‚≠ê ${score}`;
  document.getElementById("waveInfo").innerText =
    `B√∏lge ${wave}${waveInProgress ? " (i gang)" : ""}`;

  const best = localStorage.getItem(bestScoreKey) || 0;
  document.getElementById("bestScore").innerText = `Beste score: ${best}`;
}

function endGame() {
  gameRunning = false;
  const best = Math.max(score, localStorage.getItem(bestScoreKey) || 0);
  localStorage.setItem(bestScoreKey, best);
  document.getElementById("finalScore").innerText =
    `Score: ${score} (Beste: ${best})`;
  document.getElementById("overlay").style.display = "flex";
}

canvas.addEventListener("pointerdown", e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left;
  const y = e.clientY - r.top;

  // Klikk p√• t√•rn for √• velge
  selectedTower = towers.find(t => Math.hypot(t.x - x, t.y - y) < 16);
  if (selectedTower) {
    updateTowerUI();
    return;
  }

  // Ikke plass√©r p√• sti
  if (isOnPath(x, y)) return;

  const tType = towerTypes[selectedTowerType];
  if (!tType) return;

  if (money >= tType.cost) {
    towers.push(new Tower(x, y, selectedTowerType));
    money -= tType.cost;
    updateTowerUI();
  }
});

function isOnPath(x, y) {
  const threshold = 26;
  for (let i = 0; i < path.length - 1; i++) {
    const a = path[i];
    const b = path[i + 1];
    const dx = b.x - a.x;
    const dy = b.y - a.y;
    const length = Math.hypot(dx, dy);
    const t = ((x - a.x) * dx + (y - a.y) * dy) / (length * length);
    const clampedT = Math.max(0, Math.min(1, t));
    const projX = a.x + clampedT * dx;
    const projY = a.y + clampedT * dy;
    const dist = Math.hypot(x - projX, y - projY);
    if (dist < threshold) return true;
  }
  return false;
}

function updateTowerUI() {
  const ui = document.getElementById("towerUI");
  if (selectedTower) {
    const cost = selectedTower.getUpgradeCost();
    ui.innerHTML = `
      <div class="label">Valgt t√•rn</div>
      Type: ${towerTypes[selectedTower.typeKey].name}<br>
      Niv√•: ${selectedTower.level}<br>
      Skade: ${selectedTower.damage}<br>
      Rekkevidde: ${selectedTower.range}<br>
      Skuddtakt: ${selectedTower.fireRate}<br>
      <button onclick="selectedTower.upgrade()">Oppgrader (${cost})</button>
      <button onclick="sellSelectedTower()">Selg (+${Math.floor(cost/2)})</button>
    `;
  } else {
    const tType = towerTypes[selectedTowerType];
    ui.innerHTML = `
      <div class="label">Plasser t√•rn</div>
      Valgt type: ${tType.name} (kost: ${tType.cost})<br>
      Skade: ${tType.damage}, Rekkevidde: ${tType.range}
    `;
  }
}

function sellSelectedTower() {
  if (!selectedTower) return;
  const refund = Math.floor(selectedTower.getUpgradeCost() / 2);
  money += refund;
  towers = towers.filter(t => t !== selectedTower);
  selectedTower = null;
  updateTowerUI();
}

// Init UI
setupTowerShop();
updateTowerUI();
</script>
</body>
</html>
